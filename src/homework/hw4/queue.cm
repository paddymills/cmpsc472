
int end = 0;
int procs[16];
string[16] names[16];

int hayride_pids[3];

binarysem access = 1;

//method to find if a specific person is in the queue
int find_other(int start, string to_find) {
    int i;
    for (i=start; i<end; i++) {
        if ( stringCompare(names[i], to_find) == 0 )
            return i;
    }

    return -1;
}

int child8Spot(int id_to_find){
    int i = 0;
    while(i < end){
        if(procs[i] == id_to_find){
            return 1;  // 1 in this case == true
        }
        else{
            i++;
        }
    }
}

void enqueue(int proc_id, string name) {
    wait(access);
        procs[end] = proc_id;
        stringCopy(names[end], name);
        end++;
    signal(access);
}

void dequeue(int index, int& pid) {
    int i;
    int result;

    wait(access);
        pid = procs[index];

        // delete item
        procs[index] = 0;
        stringCopy(names[index], "");

        clean_queue();
    signal(access);
}

void dequeue_no_clean(int index, int& pi) {
    // dequeue item without consolidating
    // useful for when removing multiple items.
    int i;
    int result;

    wait(access);
        pid = procs[index];

        // delete item
        procs[index] = 0;
        stringCopy(names[index], "");
    signal(access);
}

void clean_queue() {
    // for cleaning queue to have no gaps
    int i;

    wait(access);
        for (i = 0; i < 16; i++) {
            if ( procs[i] == 0 ) {
                // copy next item to current
                procs[i] = procs[i+1];
                stringCopy(names[i], names[i+1]);

                // delete next item
                procs[i+1] = 0;
                stringCopy(names[i+1], "");
            }
        }

        // calculate new end
        for (i = 0; i < 16; i++) {
            if ( procs[i] == 0 ) {
                end = i;
                break;
            }
        }
    signal(access);
}

void build_ride(string output) {
    int hayride_index[3];    //array for calculating hayride (store array indexes)
    int num_on_hayride = 0;
    int num_adults = 0;
    int num_children = 0

    string[16] mother, relative, child8;
    string[16] type, tempName;
    int id;

    int i, mother_index, child8_index;

    for (i=0; i<3; i++) {
        hayride_pids[i] = 0;
    }

    // set strings for comparing
    stringCopy(mother, "Mother");
    stringCopy(relative, "Relative");
    stringCopy(child8, "Child 8");
    
    for (i = 0; i < end; i++) {
        // have to copy name to tempName because sscanf cannot handle arrays
        stringCopy(tempName, names[i]);
        sscanf(tempName, "%s %d", type, id);

        // mother or child 8
        if ( stringCompare(type, mother) == 0 || stringCompare(names[i], child8) == 0 ) {
            mother_index = find_other(i, mother);
            child8_index = find_other(i, child8);
            if ( mother_index > -1 && child8_index > -1 ) {
                // mother and child ride together
                if ( num_children < 2 && num_adults == 0) {
                    hayride_index[num_on_hayride] = mother_index;
                    hayride_index[num_on_hayride+1] = child8_index;
                    num_on_hayride += 2;
                    num_adults++;
                    num_children++;
                }
            }
            // else: mother or child8 not in queue, skip for now
        }

        // adult
        else if ( stringCompare(type, relative) == 0 ) {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
            else if ( num_adults < 2 && num_children == 0 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
        }

        // child
        else {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
            else if ( num_adults == 1 && num_children < 2 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
        }

        if (num_adults == 2 || (num_adults == 1 && num_children == 2))
            break;
    }

    if (num_adults == 2 || (num_adults == 1 && num_children == 2)) {
        // collect PIDs
        for (i=0; i<num_on_hayride; i++) {
            hayride_pids[i] = procs[hayride_index[i]];
        }

        // calc output
        stringConcat(output, names[hayride_index[0]]);
        if ( num_on_hayride == 3 ) {
            stringConcat(output, ", ");
            stringConcat(output, names[hayride_index[1]);
        }
        stringConcat(output, " and ");
        stringConcat(output, names[hayride_index[num_on_hayride-1]]);        
    }
    // TODO: else, not a full hayride picked
}

int show(int index) {
    int result;

    wait(access);
        result = data[index];
    signal(access);

    return result;
}
