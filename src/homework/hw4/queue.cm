
const int QUEUE_SIZE = 16;

int end = 0;
int procs[QUEUE_SIZE];
string[NAME_LEN] names[QUEUE_SIZE];
string[NAME_LEN] temp_queue_str;

semaphore access = 1;

// method to find if a specific person is in the queue
int find_other(int start, string to_find) {
    int i;
    for (i=start; i<end; i++) {
        if ( stringCompare(names[i], to_find) == 0 )
            return i;
    }

    return -1;
}

void clean_queue() {
    // for cleaning queue to have no 0 elements
    //      since we may remove more than one element before a clean,
    //      we cannot assume there will not be consecutive empty elements.
    //      So, we must always search for the next non-empty element

    // i = current element being fixe
    // m = for finding next element to move
    int i, m;

    // no semaphore needed because we will not call any dequeue process from main
    for (i = 0; i < QUEUE_SIZE; i++) {
        // make sure i is always behind m
        if ( procs[i] == 0 ) {
            // find next non-empty element
            m = i;
            while ( procs[m] == 0 ) {
                m++;

                // no more non-empty elements
                if (m == QUEUE_SIZE) {
                    end = i;
                    i = QUEUE_SIZE;
                    break;
                }
            }

            // non-empty elements exist
            if ( i < QUEUE_SIZE ) {
                // copy item to current
                procs[i] = procs[m];
                stringCopy(names[i], names[m]);

                // delete copied item
                procs[m] = 0;
                stringCopy(names[m], "");
            }
        }
    }
}

void enqueue(string name) {
    // must use access semaphore, because this is called in main
    wait(access);
        procs[end] = which_proc();

        stringCopy(temp_queue_str, name);
        stringCopy(names[end], temp_queue_str);

        end++;
    signal(access);
}

void dequeue(int index) {
    // WARNING! this only sets an element to nothing (0 or "")
    //    it does not consolidate the queue, so the queue will 
    //    not be continuous.
    //        must call clean_queue() to consolidate

    // no semaphore needed because we will not call
    //  any dequeue process from outside of queue.
    //  All calls ot dequeue will already hold the access semaphore
    
    // delete item
    procs[index] = 0;
    stringCopy(names[index], "");
}

void build_hayride(string output) {
    string[16] mother, relative, child8;
    string[16] type, tempName;
    int id;

    int i, mother_index, child8_index;
    int hayride_index[3];    //array for calculating hayride (store array indexes)
    int num_on_hayride = 0;
    int num_adults = 0;
    int num_children = 0;

    // set strings for comparing
    stringCopy(mother, "Mother");
    stringCopy(relative, "Relative");
    stringCopy(child8, "Child 8");
    
    // lock queue
    wait(access);
    
    // reset hayride
    for (i=0; i<3; i++) {
        hayride_pids[i] = 0;
    }

    for (i = 0; i < end; i++) {
        // have to copy name to tempName because sscanf cannot handle arrays
        stringCopy(tempName, names[i]);
        sscanf(tempName, "%s %d", type, id);

        // mother or child 8
        if ( stringCompare(type, mother) == 0 || stringCompare(names[i], child8) == 0 ) {
            mother_index = find_other(i, mother);
            child8_index = find_other(i, child8);
            if ( mother_index > -1 && child8_index > -1 ) {
                // mother and child ride together
                if ( num_children < 2 && num_adults == 0) {
                    // add mother
                    hayride_index[num_on_hayride] = mother_index;
                    num_on_hayride++;
                    num_adults++;

                    // add child
                    hayride_index[num_on_hayride] = child8_index;
                    num_on_hayride++;
                    num_children++;
                }
            }
            // else: mother or child8 not in queue, skip for now
        }

        // adult
        else if ( stringCompare(type, relative) == 0 ) {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
            else if ( num_adults < 2 && num_children == 0 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
        }

        // child
        else {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
            else if ( num_adults == 1 && num_children < 2 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
        }

        if (num_adults == 2 || (num_adults == 1 && num_children == 2) || num_children == 3)
            break;
    }

    // ******************* calc output *******************
    stringCopy(output, names[hayride_index[0]]);

    if ( num_on_hayride == 3 )
        sprintf(output, "%s, %s", output, names[hayride_index[1]]);
    
    if (num_on_hayride > 1)
        sprintf(output, "%s and %s", output, names[hayride_index[num_on_hayride-1]]);

    // collect PIDs
    for (i=0; i<num_on_hayride; i++) {
        hayride_pids[i] = procs[hayride_index[i]];
        dequeue(hayride_index[i]);
    }

    // consolidate queue
    clean_queue();

    // unlock queue
    signal(access);

    // TODO: not a full hayride picked
}
