
int end = 0;
int procs[16];
int data[16];
int ids[16];

int hayride_pids[3];

binarysem acc = 1;

void enqueue(int proc_id, int type, int proc_num) {
    // types
    //  mother = 0
    //  adult = 1
    //  child = 2
    wait(acc);
        procs[end] = proc_id;
        data[end] = type;
        ids[end] = proc_num;
        end++;
    signal(acc);
}

void dequeue(int index, int& pid, int& name) {
    int i;
    int result;

    wait(acc);
        pid = procs[index];
        name = ids[index];

        for (i = index; i < end; i++) {
            procs[i] = procs[i+1];
            data[i] = data[i+1];
        }

        // zero out item removed
        procs[end] = 0;
        data[end] = 0;
        end--;
    signal(acc);
}

void build_ride(string output) {
    int num_on_hayride = 0;
    int num_adults = 0;
    int num_children = 0

    int i = 0;
    int add_to_hayride;

    while (num_on_hayride < 3) {
        add_to_hayride = 0

        // mother
        if (data[i] == 0) {
            // must ride with child
        }

        // adult
        else if (data[i] == 1) {
            if (num_adults == 1 && num_children == 0) {
                continue;
            }
        }

        // child
        else {
            // child 8
            if (ids[i] == 8) {
                // must ride with mother
            }
        }

        // stringConcat(output, "Child 1");

        // add to hayride
        if (add_to_hayride == 1) {
            hayride_pids[num_on_hayride] = procs[i];
            num_on_hayride++;
            dequeue(i)
        }
        else {
            i++;
        }

        if (num_adults == 2 || (num_adults == 1 && num_children == 2))
            break;
    }
}

int show(int index) {
    int result;

    wait(acc);
        result = data[index];
    signal(acc);

    return result;
}

void int_repr(int num, string output) {
    if (num == 1) {
        stringConcat(output, "1");
    }
    else if (num == 2) {
        stringConcat(output, "2");
    }
    // TODO: finish
}