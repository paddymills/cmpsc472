
const int QUEUE_SIZE = 16;

int end = 0;
int procs[QUEUE_SIZE];
string[16] names[QUEUE_SIZE];

int hayride_pids[3];

binarysem access = 1;

//method to find if a specific person is in the queue
int find_other(int start, string to_find) {
    int i;
    for (i=start; i<end; i++) {
        if ( stringCompare(names[i], to_find) == 0 )
            return i;
    }

    return -1;
}

int child8Spot(int id_to_find){
    int i = 0;
    while(i < end){
        if(procs[i] == id_to_find){
            return 1;  // 1 in this case == true
        }
        else{
            i++;
        }
    }
}

void clean_queue() {
    // for cleaning queue to have no 0 elements
    int i, m; // indexes for element being written and element being moved

    // no semaphore needed because we will not call any dequeue process from main
    for (i = 0; i < QUEUE_SIZE; i++) {
        // make sure i is always behind m
        if ( procs[i] == 0 ) {
            // find next non-empty element
            m = i;
            while ( procs[m] == 0 ) {
                m++;

                // no more non-empty elements
                if (m == QUEUE_SIZE) {
                    end = i;
                    i = QUEUE_SIZE;
                    break;
                }
            }

            // non-empty elements exist
            if ( i < QUEUE_SIZE ) {
                // copy item to current
                procs[i] = procs[m];
                stringCopy(names[i], names[m]);

                // delete copied item
                procs[m] = 0;
                stringCopy(names[m], "");
            }
        }
    }
}

void enqueue(int proc_id, string name) {
    // must use access semaphore, because this is called in main
    wait(access);
        procs[end] = proc_id;
        stringCopy(names[end], name);
        end++;
    signal(access);

    suspend();
}

void dequeue(int index) {
    // WARNING! this only sets an element to nothing (0 or "")
    //    it does not consolidate the queue, so the queue will 
    //    not be continuous.
    //        must call clean_queue() to consolidate

    // no semaphore needed because we will not call any dequeue process from main
    int i;
    int result;

    // delete item
    procs[index] = 0;
    stringCopy(names[index], "");
}

void build_ride(string output) {
    string[16] mother, relative, child8;
    string[16] type, tempName;
    int id;

    int i, mother_index, child8_index;
    int hayride_index[3];    //array for calculating hayride (store array indexes)
    int num_on_hayride = 0;
    int num_adults = 0;
    int num_children = 0;
    
    for (i=0; i<3; i++) {
        hayride_pids[i] = 0;
    }

    // set strings for comparing
    stringCopy(mother, "Mother");
    stringCopy(relative, "Relative");
    stringCopy(child8, "Child 8");
    
    // lock queue
    wait(access);

    for (i = 0; i < end; i++) {
        // have to copy name to tempName because sscanf cannot handle arrays
        stringCopy(tempName, names[i]);
        sscanf(tempName, "%s %d", type, id);

        // mother or child 8
        if ( stringCompare(type, mother) == 0 || stringCompare(names[i], child8) == 0 ) {
            mother_index = find_other(i, mother);
            child8_index = find_other(i, child8);
            if ( mother_index > -1 && child8_index > -1 ) {
                // mother and child ride together
                if ( num_children < 2 && num_adults == 0) {
                    // add mother
                    hayride_index[num_on_hayride] = mother_index;
                    num_adults++;
                    num_on_hayride++;

                    // add child
                    hayride_index[num_on_hayride] = child8_index;
                    num_children++;
                    num_on_hayride++;
                }
            }
            // else: mother or child8 not in queue, skip for now
        }

        // adult
        else if ( stringCompare(type, relative) == 0 ) {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
            else if ( num_adults < 2 && num_children == 0 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_adults++;
            }
        }

        // child
        else {
            if ( num_adults == 0 && num_children < 3 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
            else if ( num_adults == 1 && num_children < 2 ) {
                hayride_index[num_on_hayride] = i;
                num_on_hayride++;
                num_children++;
            }
        }

        if (num_adults == 2 || (num_adults == 1 && num_children == 2) || num_children == 3)
            break;
    }


    // calc output
    stringConcat(output, names[hayride_index[0]]);
    if ( num_on_hayride == 3 ) {
        stringConcat(output, ", ");
        stringConcat(output, names[hayride_index[1]]);
    }
    stringConcat(output, " and ");
    stringConcat(output, names[hayride_index[num_on_hayride-1]]); 

    

    // collect PIDs
    for (i=0; i<num_on_hayride; i++) {
        hayride_pids[i] = procs[hayride_index[i]];
        dequeue(hayride_index[i]);
    }

    // consolidate queue
    clean_queue();

    // unlock queue
    signal(access);

    // TODO: not a full hayride picked
}

int is_empty() {
    int result = 0;

    wait(access);
        if (end == 0) {
            result = 1;
        }
    signal(access);

    return result;
}
