
#include <queue.cm>

semaphore seated;           // number of people seated (excludes Father)
semaphore carve_turkey;     // turkey is carved
semaphore hayride_queue;    // mutex for hayride queue
semaphore excused;          // to be excused
semaphore printMutex;	    // sem for controlling print access for the father giving hayrides

int num_seated = 0;
const int ACTION_LEN = 64;          // length of action string
const int NUM_OTHERS = 15;   // number of people not father (1 mother + 8 children + 6 relatives)

atomic void print(string title, int id, string str) {
    cout << title << " ";

    if (id > 0)
        cout << id << " ";
    
    cout << str << endl;
}


void delay(int duration) {
    // TODO: simulate delay
    int i;
    int delay;
    
    delay = random(duration * 10); 
    for (i = 0; i < delay; i++);
}

void signal_seated() {
    wait(seated);
        num_seated = num_seated + 1;
    signal(seated);
}

void mother() {
    // init vars
    string[12] title;
    string[ACTION_LEN] action;
    int id = 0;

    // set title
    stringCopy(title, "      Mother");

    // make meal
    stringCopy(action, "is preparing the meal.");
    print(title, id, action);
    delay(10);

    // put food in oven
    stringCopy(action, "is putting food in the oven.");
    print(title, id, action);
    delay(1);
    
    
    // go on hayride (with child 8)
    stringCopy(action, "is waiting for a hayride.");
    print(title, id, action);
    enqueue(which_proc, 0, 0);

    // enter house and wash up
    stringCopy(action, "is washing up.");
    print(title, id, action);
    
    // put meal on table
    stringCopy(action, "is putting the meal on the table.");
    print(title, id, action);

    // sit at table
    signal_seated();
    stringCopy(action, "is sitting at table.");
    print(title, id, action);

    // eat dinner
    wait(carve_turkey);
    stringCopy(action, "is eating.");
    print(title, id, action);

    // done eating -> be excused
    stringCopy(action, "is done eating.");
    print(title, id, action);
    wait(excused);      // wait to be excused

    // read favorite book
    stringCopy(action, "goes to read her book.");
    print(title, id, action);

}

void father() {
    int i;
    string[15] title;
    string[ACTION_LEN] action;
    int id = 0;
    
    //Print that father is hooking up the horses
    stringCopy(action, "is hooking up the horses");
    stringCopy(title, "         Father");
    print(title, id, action);
    
    delay(10);
    
    //print that the horses are hooked up and ready for hayrides
    stringCopy(action, "is done hooking up the horses");
    stringCopy(title, "         Father");
    print(title, id, action);
    
    delay(10);
    
    //give hayrides
    
    //wait untill enough people come for a hayride
    //give hayride
    //signal that more people can ride
    
    while (1) {
        wait(seated);
            if (num_seated == NUM_OTHERS) {
                signal(seated); // probably don't need this
                break;
            }
        signal(seated);
    }

    // signal turkeyis carved
    //print that father is carving the turkey
    stringCopy(action, "is carving the turkey");
    stringCopy(title, "         Father");
    print(title, id, action); 

    delay(10);

    for (i = 0; i < NUM_OTHERS; i++)
        signal(carve_turkey);

    // signal everyone is excused
    for (i = 0; i < NUM_OTHERS; i++)
        signal(excused);
        
    stringCopy(action, "excusses everyone from the table");
    stringCopy(title, "         Father");
    print(title, id, action); 
        
    //print that father is asleep watching football
    stringCopy(action, "is asleep and watching football");
    stringCopy(title, "         Father");
    print(title, id, action); 
}

void child(int id) {
    // init vars
    string[8] title;
    string[ACTION_LEN] action;

    // set title
    stringCopy(title, "   Child");

    // rake leaves
    stringCopy(action, "is raking leaves.");
    print(title, id, action);
    delay(2);

    enqueue(which_proc, 0, 0);
    
    // go on hayride
    stringCopy(action, "is waiting for a hayride.");
    print(title, id, action);
    enqueue(which_proc, 2, id);

    // clean up and sit at table
    signal_seated();
    stringCopy(action, "is sitting at table.");
    print(title, id, action);

    // eat dinner
    wait(carve_turkey);
    stringCopy(action, "is eating.");
    print(title, id, action);

    // done eating -> be excused
    stringCopy(action, "is done eating.");
    print(title, id, action);
    wait(excused);      // wait to be excused

    // go out and play
    stringCopy(action, "goes out to play.");
    print(title, id, action);
}

void relative(int id) {
    // init vars
    string[8] title;
    string[ACTION_LEN] action;

    // set title
    stringCopy(title, "Relative");

    // arrive at farm
    stringCopy(action, "arrives.");
    print(title, id, action);


    // go on hayride
    stringCopy(action, "is waiting for a hayride.");
    print(title, id, action);
    enqueue(which_proc, 1, id);

    // clean up and sit at table
    signal_seated();
    stringCopy(action, "is sitting at table.");
    print(title, id, action);

    // eat dinner
    wait(carve_turkey);
    stringCopy(action, "is eating.");
    print(title, id, action);
    delay(2);

    // done eating -> be excused
    stringCopy(action, "is done eating.");
    print(title, id, action);
    wait(excused);      // wait to be excused

    // go home
    stringCopy(action, "goes home.");
    print(title, id, action);
}

main() {
    initialsem(seated, 1);
    initialsem(carve_turkey, 0);

    // queue controls
    initialsem(hayride_queue, 1);
    initialsem(excused, 0);
    
    initialsem(printMutex, 1);

    cobegin {
        // spawn parents
        mother();
        father();

        // spawn children
        child(1);
        child(2);
        child(3);
        child(4);
        child(5);
        child(6);
        child(7);
        child(8);

        // spawn relatives
        relative(1);
        relative(2);
        relative(3);
        relative(4);
        relative(5);
        relative(6);
    }
}
